"use strict";class NetworkUtils{constructor(){this.pendingRequests=new Map,this.requestCache=new Map,this.cacheTimeout=3e4}async withRetry(e,t={}){const{maxRetries:s=3,baseDelay:r=1e3,maxDelay:a=1e4,backoffFactor:i=2,retryOn:n=e=>!0,onRetry:u=null}=t;let c;for(let t=0;t<=s;t++)try{return await e()}catch(e){if(c=e,t===s||!n(e))throw e;const h=Math.min(r*Math.pow(i,t),a),o=.1*h*Math.random(),l=h+o;u&&u(t+1,l,e),await this.sleep(l)}throw c}async dedupe(e,t){if(this.pendingRequests.has(e))return this.pendingRequests.get(e);const s=t().finally(()=>{this.pendingRequests.delete(e)});return this.pendingRequests.set(e,s),s}async cached(e,t,s=this.cacheTimeout){const r=this.requestCache.get(e);if(r&&Date.now()-r.timestamp<s)return r.data;const a=await t();return this.requestCache.set(e,{data:a,timestamp:Date.now()}),a}clearCache(e=null){e?this.requestCache.delete(e):this.requestCache.clear()}sleep(e){return new Promise(t=>setTimeout(t,e))}isRetryableError(e){if("TypeError"===e.name&&e.message.includes("fetch"))return!0;if(e.status){if(e.status>=500&&e.status<600)return!0;if(429===e.status)return!0;if(408===e.status)return!0}if(e.code){const t=["PGRST301","57P01","57P02","57P03","08000","08003","08006"];return t.includes(e.code)}return!1}async supabaseWithRetry(e,t={}){return this.withRetry(e,{maxRetries:2,baseDelay:500,retryOn:this.isRetryableError.bind(this),...t})}}window.networkUtils=new NetworkUtils,console.log("âœ… Network Utils - Loaded");